
% Copyright 2011 by Zonglei Zhen
\documentclass{beamer}

% Setup appearance:
\usetheme{Goettingen}

% Standard packages
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{CJK}

\setbeamertemplate{footline}[frame number]


% Author, Title, etc.
\author[]{Neuroimaging and Informatics Team}

\institute{Beijing Normal University,China}
\date{\today}



% The main document
\begin{document}
\begin{CJK*}{GBK}{song}

\title[PyBP]{PyBP: Python for Brain Parcellation}
\begin{frame}
  \titlepage
\end{frame}

\section{Intro}
\begin{frame}{PyBP}
PyBP: A versatile toolbox to  partition the brain into different subunits
    \begin{enumerate}
        \item input: anatomical or functional neuroimaging data
        \item process: segment the brain into different based on some criterion.
        \item output: ROIs in NII format and object in HDF5
    \end{enumerate}
\end{frame}

\begin{frame}{Dependencies}
    \begin{enumerate}
        \item Python
        \item Pymvpa
        \item NIPY
        \item Nipype
        \item Subversion
    \end{enumerate}
\end{frame}

\begin{frame}{ROI Making}
    \begin{enumerate}
        \item manually operation
        \item Automatic method
        \item Semiautomatic method
    \end{enumerate}
\end{frame}

\section{Design}
\begin{frame}{Learn from Pymvpa}
直接把数据提取，然后丢掉了空间近邻信息。但信息保存在map中，所以是否可以采用pymvpa的架构，直接利用matrix和mapper，然后利用后续算法进行操作？
    \begin{enumerate}
         \item Base: base class for all module？
         \item Datasets: IO
         \item Mapper：preprocessing and transform
         \item Measure：distance or similarity
         \item Clfs：classifer
         \item Algorithms：general algorithms except Clfs?
         \item Kernels：Kernels to compute the distance in high dimension.
         \item Featsel：feature selection
    \end{enumerate}
\end{frame}


\begin{frame}{Principal of PyBP Design}
   \begin{block}{直接基于pymvpa}
        优势: 框架设计良好，和其它软件接口设计良好。
        缺点: 是为decoding 专门设计，很多特征不是我们所需的。
    \end{block}
   \begin{block}{Tradeoff}
        借鉴pymvpa,nipy，把整个过程拆分成不同module，每个module逻辑上相对独立，具有共同基类, module 中其它类均从其继承。
        增添针对PyBP的特有module: Neighbor,Sparse. 这种才能真正学习设计，让我们进步，我们必须采用这类方法。
   \end{block}
\end{frame}

\begin{frame}{Object in PyBP}
    \begin{block}{Input}
        \begin{enumerate}
            \item Task fMRI(Label or Volume)
            \item Rest fMRI
            \item DTI
            \item MRI
            \item Connectivity matrix
        \end{enumerate}
    \end{block}

    \begin{block}{Output}
    	\begin{enumerate}
         \item Volume ROI
         \item Surface ROI
         \end{enumerate}
    \end{block}

    \begin{block}{Process or Algorithms}
    	\begin{enumerate}
            \item Supervised:Generative model(Bayes, Dictionary learning,Hierarchy model)
            \item Unsupervised: Watershed, Region Growing, Clustering,ICA,PCA
            \item GraphCut: Connectivity based segmentation
        \end{enumerate}
    \end{block}
\end{frame}


\begin{frame}{Platform}
    \begin{enumerate}
        \item Format(volume and surface)
        \item Software(FSL,SPM,Freesurfer,Caret)
    \end{enumerate}
\end{frame}



\begin{frame}{ROI Making}
\begin{block}{Manually operation}
    \begin{enumerate}
        \item Display the map
        \item Draw the ROI manually and save ROI
    \end{enumerate}
\end{block}

\begin{block}{Semiautomatic method}
    \begin{enumerate}
        \item Segment contrast probabilistic map to generate group ROI(Ncut,Watershed,K-means).
        \item Generate individual subject ROI guiding by group ROI.
    \end{enumerate}
\end{block}

\begin{block}{Automatic method}
    \begin{enumerate}
        \item Generate feature(fMRI, rs-fcMRI, DTI) for labeled voxel.
        \item Train the model
        \item Predict non-training voxels or subject
    \end{enumerate}
\end{block}
\end{frame}

\begin{frame}{Basic function}
    \begin{enumerate}
        \item Draw ROI manually(fROI,pyQTGraph,pyQwt)
        \item Find peak(peak\_nii)
        \item Probabilistic map(SPM anatomy toolbox)
        \item Combine volume and surface(pyROI)
        \item Good Framework (pymvpa)
        \item Extract signal of ROI(fROI,marsBar)
        \item Automatic method(our features)
        \item Fiji(http://fiji.sc/wiki/index.php/Fiji,
            http://132.187.25.13/home/?category=Download&page=SegmentationEditor,
            http://132.187.25.13/home/?page=ImageJ&category=Download)
        \item ITK-SNAP(www.itksnap.org/)
    \end{enumerate}
\end{frame}

\section{Misc}

\begin{frame}{GUI coordinate system}
    \begin{block}{Windows vs. viewport}
        \begin{enumerate}
            \item 窗口是虚拟，逻辑对象，看不到。窗口使用逻辑坐标，如mm
            \item 视口在设备上实现了窗口，实际在设备上看到。视口使用设备坐标，如pixel
        \end{enumerate}
    \end{block}


        \begin{block}{Coordinate}
        \begin{enumerate}
            \item 逻辑坐标系是指用于指定逻辑坐标的坐标系，视口坐标系是指用于指定设备坐标的坐标系。
            \item 窗口和视口原点均为目标窗口和视口左上角，为是同一点，只是以不同的坐标系表示而已，因为后者是前者的物理实现。
            \item 设备坐标系分为屏幕坐标系、窗口坐标系和客户区坐标系三种相互独立的坐标系。
        \end{enumerate}
    \end{block}
\end{frame}


\end{CJK*}
\end{document}

